01-6 | undefined와 null
---
### 01-6 | undefined와 null
자바스크립트에는 '없음'을 나타내는 값이 두 가지가 있다. 바로 undefined와 null이다. 두 값의 의미는 같은 것 같지만 미세하게 다르고, 사용하는 목적 또한 다르다.

우선 undefined에 대해서 살펴볼 것이다. undefined는 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 있다. 

사용자가 명시적으로 undefined를 지정하는 경우는 달리 덧붙일 내용이 없어 넘어가고, 자바스크립트 엔진이 자동으로 부여하는 경우에 대해 살펴볼 것이다.

자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환한다. 다음 세 경우가 이에 해당한다.

(예제 1-19)
```
(1) 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
(2) 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
(3) return 문이 없거나 호출되지 않는 함수의 실행 결과
```

```
// 예제 1-19 | 자동으로 undefined를 부여하는 경우
01  var a;
02  console.log(a); // (1) undefined. 값을 대입하지 않은 변수에 접근
03
04  var obj = { a : 1 };
05  conosle.log(obj.a); // 1
06  console.log(obj.b); // (2) 존재하지 않는 프로퍼티에 접근
07  console.log(b); // c.f) ReferenceError : b is not defined
08
09  var func = function(){};
10  var c = func(); // (3) 반환(return) 값이 없으면 undefined를 반환한 것으로 간주
11  console.log(c); // undefined
```

그런데 위의 (1) 값을 대입하지 않은 경우에 대해 배열의 경우에는 조금 특이한 동작을 확인할 수 있다. 우선 예제 1-20을 먼저 보자.

```
// 예제 1-20 | udnefined와 배열
01  var arr1 = [];
02  arr1.length = 3;
03  console.log(arr1); // [empty x 3 ]
04
05  var arr2 = new Array(3);
06  console.log(arr2); // [empty x 3 ]
07
08  var arr23 = [undefined, undefined, undefined];
09  console.log(arr3); // [undefined,undefined,undefined]
```

1번째 줄에서 빈 배열을 만들고, 2번째 줄에서 배열의 크기를 3으로 하자 3번재 줄에서 [ empty x 3 ]이 출력됐다. 이는 배열에 3개의 빈 요소를 확보했지만 확보된 각 요소에는 문자 그대로 어떤 값도, 심지어 undefined 조차도 할당돼 있지 않음을 의미한다.

5번째 줄에서는 new 연산자와 함께 Array 생성자 함수를 호출함으로써 배열 인스턴스를 생성했는데, 이때 배열의 크기는 3으로 지정했다. 6번째 줄에서 출력된 결과는 arr1과 같다. 한편 8번째 줄에서는 리터럴 방식으로 배열을 생성하면서 각 요소에 undefined를 부여했다. 9번째 줄의 출력 결과는 3번째 및 6번째 줄의 결과와 다른 것을 확인할 수 있다.

이처럼 '비어있는 요소'와 'undefined를 할당한 요소'는 출력 결과부터 다르다. '비어있는 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다. 예제 1-21을 통해 확인해 볼 수 있다.
```
// 예제 1-21 | 빈 요소의 배열의 순회
01  var arr1 = [ undefined, 1 ];
02  var arr2 = [];
03  arr2[1] = 1;
04
05  arr1.forEach(function(v,i) {console.log(v,i);}); // undefined 0 / 1 1
06  arr2.forEach(function(v,i) {console.log(v,i);}); // 1 1
07
08  arr1.map(function(v,i){return v+i}); // [NaN, 2];
09  arr2.map(function(v,i){return v+i}); // [ empty, 2 ];
10
11  arr1.filter(function(v){return!v}); // [ undefined ];
12  arr2.filter(function(v){return!v}); // [ ];
13
14  arr1.reduce(function(p,c,i){return p+c+i}, ''); // undefined011
15  arr2.reduce(function(p,c,i){return p+c+i}, ''); // 11
```

예제 1-21의 arr1은 undefined와 1을 직접 할당한 반면 arr2는 빈 배열의 인덱스 1에 값 1을 할당했다.
이 두 배열은 배열의 각 요소를 순회하는 것을 기본으로 추가적인 기능을 수행하는 메서드들, 즉 forEach, map, filter, reduce등에서 서로 다른 결과를 보인다.
사용자가 직접 undefined를 할당한 arr1에 대해서는 일반적으로 알고 있는 대로 배열의 모든 요소를 순회해서 결과를 출력한다. 
그러나 arr2에 대한 결과를 보면, 각 메서드들이 비어 있는 요소에 대해서는 어떠한 처리도 하지 않고 건너뛰었음을 알 수 있다.

이러한 동작은 배열에서만 발견할 수 있는 특별한 현상인 것처럼 소개했지만, 사실은 **배열도 객체**임을 생각해보면 지극히 자연스러운 현상이다. 존재하지 않는 프로퍼티에 대해서는 순회할 수 없는 것이 당연하다.
배열은 무조건 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스를 이름으로 지정할 것이라고 생각하기 쉽지만, 실제로는 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고, 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 등의 동작을 한다.
즉, 값이 지정되지 않은 인덱스는 '아직은 존재하지 않는 프로퍼티'에 지나지 않는 것이다.

그렇다면 사용자가 명시적으로 부여한 경우와 비어있는 요소에 접근하려 할 때 반환되는 두 경우의 'undefined'의 의미를 구분할 수 있다. 전자의 undefined는 그 자체로 값이다. undefined가 비록 '비어있음'을 의미하긴 하지만 하나의 값으로 동작하기 때문에 이때의 프로퍼티나 배열의 요소는 고유의 키값(프로퍼티 이름)이 실존하게 되고, 따라서 순회의 대상이 될 수 있다.
한편 사용자가 아무것도 하지 않은 채로 접근했을 때 자바스크립트 엔진이 하는 수 없이 반환해주는 undefined는 해당 프로퍼티 내지 배열의 키 값(인덱스) 자체가 존재하지 않음을 의미한다. 
값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined 문자 그대로 값이 없음을 나타내는 것이다.

```
예제 1-19의 [1]의 '값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때 undefined를 반환한다'는 내용은 다른 자바스크립트 입문서에서 소개하는 내용과는 거리가 있다.
즉 'var a'라는 구문에의해 식별자 a에 자동으로 undefined가 '할당된다'고 소개하는 것이 일반적이다. 
그런데 자바스크립트가 실제로 그렇게 동작하는 것은 아니다. 
정확히는 아무것도 할당하지 않고 끝나며, 이후 변수a에 접근하고자 할 때 비로소 undefined를 반환하는 것이 맞다.

많은 자바스크립트 입문서에서 '변수 선언 시 자동으로 undefined를 할당한다'고 소개하는 까닭은 일반적으로 undefined의 의미를 깊게 다루는 것이 입문자에게는 혼란을 가중시킬 뿐 자바스크립트 전반의 이해에는 큰 도움이 되지 않는다고 판단했기 때문이 아닐까 싶다.
```

undefined에 대해서 혼란스러우니까 자바스크립트 엔진이 직접할당하는 경우는 우리의 통제 범위를 벗어 남으로 우리가 직접 undefined를 할당하지 않는 것으로 복잡함을 해결할 수 있다.

같은 의미를 가진 null이라는 값이 별도로 있는데 굳이 undefined를 써야 할 이유가 없다. '비어있음'을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null을 쓰면 된다.
null은 애초부터 이런 용도로 만든 데이터 타입이다. 이런 규칙을 따르는 한 undefined는 오직 '값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값'으로서만 존재할 수 있다.

추가로 null은 한 가지 주의할 점이 있다. 바로 typeof null이 object라는 점이다. 이는 자바스크립트 자체 버그이다. 다라서 어떤 변수의 값이 null인지 판별하기 위해서는 typeof 대신 다른 방식으로 접근해야 한다. 예제 1-22를 살펴보자.
```
01  var n = null;
02  console.log(typeof n); // object
03
04  console.log(n == undefined); // true
05  console.log(n == null); // true
06
07  console.log(n === null); // true
08  console.log(n === undefined); // false
```

4번째 줄과 같이 동등 연산자(equality operator)(==)로 비교할 경우 null과 undefined가 서로 같다고 판단한다. 따라서 어떤 변수가 실제로 null인지 아니면 undefined인지는 동등 연산자로 비교해서는 알 수 없다. 7번째 및 8번째 줄과 같이 일치 연산자(identify operator)(===)를 써야만 정확히 판별할 수 있다.
