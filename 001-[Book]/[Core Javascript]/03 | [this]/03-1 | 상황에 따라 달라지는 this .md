03 | this
===
자바스크립트에서 가장 혼란스러운 개념을 고르라고 하면 많은 사람들이 망설임 없이 this를 꼽을 것입니다.
다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스턴스 객체를 의미합니다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않습니다. 그러나 자바스크립트에서의 this는 어디서든 사용할 수 있습니다.
상황에 따라 this가 바라보는 대상이 달라지는데, 어떤 이유로 그렇게 되는지를 파악하기 힘든 경우도 있고 예상과 다르게 엉뚱한 대상을 바라보는 경우도 있습니다. 이런 경우에는 문제를 해결하려면 원인을 추적해서 수정해야 하는데, 정확한 작동 방식을 이해하지 못하면 원인을 파악해서 해결할 수 없겠죠.

함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능입니다. 이번 장에서는 상황별로 this가 어떻게 달라지는지, 왜 그렇게 되는지, 예상과 다른 대상을 바라보고 있을 경우 그 원인을 효과적으로 추적하는 방법 등을 살펴보겠습니다.

---
03-1 | 상황에 따라 달라지는 this
---
자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다. 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 this**는 함수를 호출할 때 결정된다**라고 할 수 있겠습니다.
함수를 어떤 방식으로 호출하냐에 따라 값이 달라지는 것입니다. 지금부터는 다양한 상황과 각 상황별로 this가 어떤 값을 보게 되는지를 살펴보고, 가능하면 그 원인도 함께 알아봅시다.

---

###03-1-1 | 전역 공간에서의 this
전역 공간에서 this는 전역 객체를 가리킵니다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문입니다. 
전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있습니다. 브라우저 환경에서 전역객체는 window이고 Node.js 환경에서는 global입니다.

```
// 예제 3-1 | 전역 공간에서의 this(브라우저 환경)
console.log(this); // { alert : f(), blur : f(), btoa : f () ... }
console.log(window); // { alert : f(), blur : f(), btoa : f () ... }
console.log(this === window); // true
```

```
// 예제 3-2 | 전역 공간에서의 this(Node.js 환경)
console.log(this); // { process : { title : 'node', version : 'v10.13.0', ... } }
console.log(global); // { process : { title : 'node', version : 'v10.13.0', ... } }
console.log(this === global); // true
```

이번 장의 주제인 this와 큰 관련은 없지만 전역 공간을 다루는 김에 잠시 전역 공간에서만 발생하는 특이한 성질 하나를 살펴보고 넘어가겠습니다. 
전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로도 할상합니다. 변수이면서 객체의 프로퍼티이기도 한 셈이죠. 코드로 확인해 봅시다.
참고로 3번째 줄의 window를 global로 바꾸면 Node.js 환경에서도 같은 동작을 확인할 수 있습니다.

```
// 예제 3-3 | 전역변수와 전역객체(1)
var a = 1;
console.log(a); // 1
console.log(window.a); // 1
console.log(this.a); // 1
```

전역공간에서 선언한 변수 a에 1을 할당했을 뿐인데 window.a 와 this.a 모두 1이 출력됩니다. 전역공간에서의 this는 전역객체를 의미하므로 두 값이 같은 값을 출력하는 것은 당연하지만, 그 값이 1인 것이 의아합니다.
그 이유는 **자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티**로서 동작하기 때문입니다. 사용자가 var 연산자를 이용해 변수를 선언하더라도 실제 자바스크립트 엔진은 어떤 특정 객체의 프로퍼티로 인식하는 것입니다.
특정 객체란 바로 실행 컨텍스트의 LexicalEnvironment입니다. 실행 컨텍스트는 변수를 수집해서 L.E의 프로퍼티로 저장합니다. 
이후 어떤 변수를 호출하면 L.E를 조회해서 일치하는 프로퍼티가 있을 경우 그 값을 반환합니다. 전역 컨텍스트의 경우 L.E는 전역객체를 그대로 참조합니다.

앞에서 '전역변수를 선언하면 자동으로 전역객체의 프로퍼티로도 할당한다'고 했는데, 이제 이 문장이 틀렸다는 걸 이해하실 것입니다. 정확히 표현하면 '**전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다**'가 되겠죠. 
그렇다면 window.a나 this.a가 1이 나오는 이유는 설명되는데, a를 직접 호출할 때도 1이 나오는 까닭은 무엇일까요? 이는 변수 a에 접근하고자 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 L.E, 즉 전역객체에서 해당 프로퍼티 a를 발견해서 그 값을 반환하기 때문입니다.
원리는 이렇지만 그냥 단순하게 (window.)이 생략된 것이라고 여겨도 무방합니다.

이쯤에서 눈치 빠른 독자라면 전역 공간에서는 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 var로 선언한 것과 똑같이 동작할 것이라는 예상을 할 수 있을 것입니다. 대부분의 경우에는 이 말이 맞습니다.
```
// 예제 3-4 | 전역변수와 전역객체(2)
01  var a = 1;
02  window.b  = 2;
03  console.log(a, window.a, this.a); // 1 1 1
04  console.log(b, window.b, this.b); // 2 2 2
05  
06  window.a = 3;
07  b = 4;
08  console.log(a, window.a, this.a); // 3 3 3
09  console.log(b, window.b, this.b); // 4 4 4
```

그런데 전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 있습니다. 바로 '삭제' 명령에 대해 그렇습니다.

```
// 예제 3-5 | 전역변수와 전역객체(3)
var a = 1;
deleete window.a; // false
console.log(a, window.a, this.a); // 1 1 1
```
```
var b = 2;
delete b; // false
console.log(b, window.b, this.b); // 2 2 2
```
```
window.c = 3;
delete window.c; // true
console.log(c, window.c, this.c); // Uncaught ReferenceError : c is not defined 
```
```
window.d = 4;
delete window.d; // true
console.log(d, window.d, this.d); // Uncaught ReferenceError : d is not defined
```

변수에 delete 연산자를 쓰는 것이 이상해보일 수도 있는데, 앞서 설명한 바와 같이 (window.)을 생략한 것으로 이해하면 됩니다.
전역변수가 곧 전역객체의 프로퍼티이므로 문제가 되지 않습니다.

다만 예제를 살펴보면 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는 것을 확인할 수 있습니다.
이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략이라고 해석됩니다. 즉 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추라적으로 해당 프로퍼티의 configurable 속성( 변경 및 삭제 가능성 )을 false로 정의하는 것 입니다.

이처럼 var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보입니다.

---
###03-1-2 | 메서드로서 호출할 때 그 메서드 내부에서의 this

#### 함수 vs 메서드
어떤 함수를 실행하는 방법은 여러 가지가 있는데, 가장 일반적인 방법 두 가지는 함수로서 호출하는 경우와 메서드로서 호출하는 경우입니다. 
프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 **독립성**에 있습니다. 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행합니다.
자바스크립트는 상황별로 this 키워드에 다른 값을 부여하게 함으로써 이를 구현했습니다.

자바스크립트를 처음 접하는 분들은 흔히 메서드를 '객체의 프로퍼티에 할당된 함수'로 이해하곤 합니다. 반은 맞고 반은 틀립니다. 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다. 예제를 보죠.

```javascript
var func = function(x){
    console.log(this, x);
};
func(1);    // Window { ... } 1

var obj = {
    method : func
};
obj.method(2); // { methid : f } 2
```
1번째 줄에서 func라는 변수에 익명함수를 할당했습니다. 4번째 줄에서 func를 호출했더니 this로 전역객체 Window가 출력됩니다.
6번째 줄에서 obj라는 변수에 객체를 할당하는데, 그 객체의 method 프로퍼티에 앞에서 만든 func함수를 할당했습니다. 이제 9번째 줄에서 obj의 method를 호출했더니, 이번에는 this가 obj라고 합니다. obj의 method 프로퍼티에 할당한 값과 func 변수에 할당한 값은 모두 1번재 줄에서 선언한 함수를 참조합니다.
즉 원래의 익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것입니다.

그렇다면 '함수로서 호출'과 '메서드로서 호출'을 어떻게 구분할까요? 함수 앞에 점(.)이 있는지 여부만으로 간단하게 구분할 수 있습니다. 예제 3-6의 4번째 줄은 앞에 점이 없으니 함수로서 호출한 것이고, 9번째 줄은 method 앞에 점이 있으니 메서드로서 호출한 것입니다. 정말입니다. (물론 대괄호 표기법에 따른 경우에도 메서드로서 호출한 것입니다.).
```javascript
var obj = {
    method : function(x){console.log(this,x);}
};
obj.method(1); // { method : f } 1
obj['method'](2); // { method : f } 2
```

다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명)앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것입니다.

---
#### 메서드 내부에서의 this

this에는 호출한 주체에 대한 정보가 담깁니다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체입니다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this가 되는 것입니다.

```javascript
// 예제 3-8 | 메서드 내부에서의 this
var obj = {
    methodA : function() { console.log(this); },
    inner : {
        methodB : function() { console.log(this); }
    }
};
obj.methodA();              // { method : f, inner : { ... } } ( === obj )
obj['methodA']();           // { method : f, inner : { ... } } ( === obj )

obj.inner.methodB();        // { methodB : f }             ( === obj.inner )
obj.inner['methodB']();     // { methodB : f }             ( === obj.inner )
obj['inner'].methodB();     // { methodB : f }             ( === obj.inner )
obj['innner']['methodB'](); // { methodB : f }             ( === obj.inner )
```
---
###03-1-3 | 함수로서 호출할 때 그 함수 내부에서의 this

#### 함수 내부에서의 this

어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않습니다. this에는 호출한 주체에 대한 정보가 담긴다고 했습니다. 
그런데 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것입니다. 
2장에서 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라본다고 했습니다. 따라서 함수에서의 this는 전역 객체를 가리킵니다. 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적합니다.
그 이유는 바로 이어서 설명하겠습니다.

#### 메서드의 내부함수에서의 this

메서드 내부에서 정의하고 실행한 함수에서의 this는 자바스크립트 초심자들이 this에 관해 가장 자주 혼란을 느끼는 지점 중 하나입니다. 앞서 소개한 '설계상의 오류'로 인해 실제 동작과 다르게 예측하곤 합ㄴ디ㅏ.
this라는 단어 자체가 주는 느낌적 느낌 그대로 코드를 바라보면 예상과 다른 결과가 나옵니다. 그러나 우리는 이미 어떤 함수를 메서드로서 호출할 때와 함수로서 호출할 때 this가 무엇을 가리키는지를 알고 있습니다. 내부함수 역시 이를 함수로서 호출했는지 메서드로서 호출했는지만 파악하면 this의 값을 정확히 맞출 수 있습니다. 다음 예제의 각 console.log 위치에서 this가 무엇을 가리키는지 예상해보고 정답과 비교해 보세요. (2)는 innerFunc를 호출한 결과를, (3)은 obj2.innerMethod를 호출한 결과를 의미합니다.
```javascript
var obj1 = {
    outer : function() {
        console.log(this); // (1)
        var innerFunc = function(){
            console.log(this);  // (2) (3)
        }
        innerFunc();
        
        var obj2 = {
            innerMethod : innerFunc
        };
        obj2.innerMethod();
    }
};
obj1.outer();
```
정답은 (1) : obj1, (2) : 전역객체(Window), (3) : obj2 입니다. 코드 흐름을 따라가면서 분석해 봅시다.

- 1번째 줄 : 객체를 생성하는데, 이때 객체 내부에는 outer라는 프로퍼티가 있으며, 여기에는 익명함수가 연결됩니다. 이렇게 생성한 객체를 변수 obj1에 할당합니다.
- 15번째 줄 : obj1.outer를 호출합니다.
- 2번째 줄 : obj1.outer 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩합니다. 이 함수는 호출할 때 함수명인 outer앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다. 따라서 this에는 마지막 점 앞의 객체인 obj1이 바인딩됩니다.
- 3번째 줄 : obj1 객체 정보가 출력됩니다.
- 4번째 줄 : 호이스팅된 변수 innerFunc는 outer 스코프 내에서만 접근할 수 있는 지역변수입니다. 이 지역변수에 익명함수를 할당합니다.
- 7번째 줄 : innerFunc 함수를 호출합니다.
- 4번째 줄 : innerFunc 함수의 실행 컨텍스트가 생성되면서 호이스팅, 스코프 체인 수집, this 바인딩 등 을 수행합니다. 이 함수를 호출할 때 함수명 앞에는 점(.)이 없었습니다. 즉 함수로서 호출한 것으로 this가 지정되지 않았고, 따라서 자동으로 스코프 체인상의 최상위 객체인 전역객체(Window)가 바인딩됩니다.
- 5번째 줄 : Window 객체 정보가 출력됩니다.
- 9번째 줄 : 호이스팅된 변수 obj2 역시 outer 스코프 내에서만 접근할 수 있는 지역변수입니다. 여기에는 다시 객체를 할당하는데, 그 객체에는 innerMethod라는 프로퍼티가 있으며, 여기에는 앞서 정의된 변수 innerFunc와 연결된 익명 함수가 연결됩니다.
- 12번째 줄 : obj2.innerMethod를 호출합니다.
- 9번째 줄 : obj2.innerMethod 함수의 실행 컨텍스트가 실행됩니다. 이 함수는 호출할 때 함수명인 innerMethod 앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다. 따라서 this에는 마지막 점 앞의 객체인 obj2가 바인딩됩니다.
- 10번째 줄 : obj2 객체 정보가 출력됩니다.

7번째 줄에서는 outer 메서드 내부에 있는 함수(innerFunc)를 함수로서 호출했습니다. 반면 12번째 줄에서는 같은 함수(innerFunc)를 함수로서 호출했습니다. 
반면 12번째 줄에서는 같은 함수(innerFunc)를 메서드로서 호출했습니다. 같은 함수임에도 7번째 줄에 의해 바인딩되는 this와 12번째 줄에 의해 바인딩되는 this의 대상이 서로 달라진 것이죠.

그러니까 this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건인 것입니다.

---
#### 메서드의 내부 함수에서의 this를 우회하는 방법

이렇게 하면 this에 대한 구분은 명확히 할 수 있지만, 그 결과 this라는 단어가 주는 인상과는 사뭇 달라져 버렸습니다. 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠습니다.
그게 훨씬 자연스러울뿐더러 자바스크립 설계상 이렇게 동작하는 편이 스코프 체인과의 일관성을 지키는 설득력 있는 방식이었습니다. 변수를 검색하면 우선 가장 가까운 스코프의 L.E를 찾고 없으면 상위 스코프를 탐색하듯이, this 역시 현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 말이죠.
그러나 사용자 입장에서는 어색하거나 설득력 없는 기능들이라 하더라도 그 자체를 언어가 가지는 고유한 특성으로 받아들이고 주어진 환경에 적응할 수밖에 별다른 도리가 없습니다. 아쉽게도 ES5까지는 자체적으로 내부함수에 this를 상속할 방법이 없지만 다행히 이를 우회할 방법이 없지는 않습니다. 그중 대표적인 방법은 바로 변수를 활용하는 것입니다. 

```javascript
// 예제 3-10 | 내부함수에서의 this를 우회하는 방법
var obj = {
    outer : function () {
        console.log(this);      // (1) { outer : f }
        var innerFunc1 = function () {
            console.log(this);      // (2) Window { ... }
        };
        innerFunc1();
        
        var self = this;
        var innerFunc2 = function(){
            console.log(self);      // (3) { outer : f }
        };
        innerFunc2();
    }
};
obj.outer();
```

위 예제의 innerFunc1 내부에서 this는 전역객체를 가리킵니다. 한편 outer 스코프에서 self라는 변수에 this를 저장한 상태에서 호출한 innerFunc2의 경우 self에는 객체 obj가 출력됩니다.
우회라고 할 수도 없을 만큼 허무한 방법이지만 기대에는 충실히 부합합니다. 사람마다 _this, that, 혹은 _ 등 제각각 다른 변수명을 쓰는데, self가 가장 많이 쓰이는 것 같습니다.
그저 상위 스코프의 this를 저장해서 내부함수에서 활용하려는 수단일뿐이므로 의미만 통한다면 변수명을 무엇으로 정해도 무관합니다. 다만 원활한 협업이나 의사소통을 위해서는 널리 쓰이는 단어를 활용하는 것이 바람직하겠죠.

---
#### this를 바인딩하지 않는 함수

ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수 ( arrow function )를 새로 도입했습니다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있습니다.
내부 함수를 화살표 함수로 바꾸면 3-1-3-3절의 '우회법'이 불필요해집니다. ( 아쉽게도 ES5환경에서는 화살표 함수를 사용할 수 없습니다. )

```javascript
// 예제 3-11 | this를 바인딩하지 않는 함수 (화살표 함수)
var obj = {
    outer : function(){
        console.log(this);      // (1) { outer : f }
        var innerFunc = () => {
            console.log(this);      // (2) { outer : f}
        };
        innerFunc();
    }
};
obj.outer();
```

그 밖에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법이 있습니다. 이러한 방법에 대해서는 3-2절에서 소개하겠습니다.

---
### 03-1-4 | 콜백 함수 호출 시 그 함수 내부에서의 this

콜백 함수의 정의와 동작 원리 등에 대해서는 바로 다음 장에서 자세히 다룹니다. 여기서는 this가 어떤 값으 참조하는지만 간단히 확인하고 넘어가겠습니다.

함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 합니다.
이때 함수 A는 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정됩니다.
콜백 함수도 함수이기 때문에 기본적으로 3-1-3절에서와 마찬가지로 this가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 됩니다.

다음은 대표적인 콜백 함수입니다. 각각 어떤 값이 출력되는지를 예측해보고 결과와 비교해보시기 바랍니다. (3)의 경우 브라우저 콘솔창에서 실행한 다음 웹페이지 상의 '클릭' 버튼을 클릭할 때 비로소 결과가 출력됩니다.

```javascript
// 예제 3-12 | 콜백 함수 내부에서의 this
setTimeout(funciton () { console.log(this); }, 300 );        // (1)

[1, 2, 3, 4, 5].forEach(function(x){
    console.log(this,x);                                    // (2)
});

document.body.innerHTML += '<button id="a">클릭</button>';
document.body.querySelector('#a')
    .addEventListener('click', function(e){
        console.log(this,e);                                // (3)
    });
```

- (1) : setTimeout 함수는 300ms 만큼 시간 지연을 한 뒤 콜백 함수를 실행하라는 명령입니다. 0.3초 뒤 전역객체가 출력됩니다.
- (2) : forEach 메서드는 배열의 각 요소를 앞에서부터 차례대로 하나씩 꺼내어 그 값을 콜백 함수의 첫 번째 인자로 삼아 함수를 실행하라는 명령입니다. 전역객체와 배열의 각 요소가 총 5회 출력됩니다.
- (3) : addEventListener 는 지정한 HTML 엘리먼트에 'click' 이벤트가 발생할 때마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행하라는 명령입니다. 버튼을 클릭하면 앞서 지정한 엘리먼트와 클릭 이벤트에 관한 정보가 담긴 객체가 출력됩니다.

(1)의 setTimeout 함수와 (2)의 forEach 메서드는 그 내부에서 콜백 함수를 호출할 때 대상이 될 this를 지정하지 않습니다. 따라서 콜백 함수 내부에서의 this는 전역객체를 참조합니다. 
한편 (3)의 addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있습니다. 그러니까 메서드명의 점(.) 앞부분이 곧 this가 되는 것이죠.

이처럼 콜백 함수에서의 this는 '무조건 이거다!'라고 정의할 수 없습니다. 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라봅니다.

---
### 03-1-5 | 생성자 함수 내부에서의 this

생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수입니다.
객체지향 언어에서는 생성자를 클래스(class), 클래스를 통해 만든 객체를 인스턴스(instance)라고 합니다. ( 클래스에 관해서는 7장에서 자세히 다룰 예정입니다. 지금은 this와 관련있는 내용만 간랸히 소개하겠습니다. )

현실세계에서 '인간'의 공통 특성 몇 가지만 생각해 보자면 직립 보행, 언어 구사, 도구 사용 등을 들 수 있겠죠.
이런 공통 속성들을 모아 인간 집합을 정의한 것이 바로 클래스이며, 각 사람들은 인간 클래스에 속하는 인스턴스입니다. 각 인스턴스들은 위에 예로 든 공통점들도 있지만 저마다의 개성도 존재할 수 있습니다.
프로그래밍적으로 '생성자'는 **구체적인 인스턴스를 만들기 위한** 일종의 **틀**입니다. 이 틀에는 해당 클래스의 공통 속성들이 미리 준비돼 있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있는 것이죠.

자바스크립트는 함수에 생성자로서의 역할을 함께 부여했습니다. new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 됩니다.
그리고 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 됩니다.

생성자 함수를 호출(new 명령어와 함께 함수를 호출)하면 우선 생성자의 prototype 프로퍼티를 참조하는 __ proto __ 라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여합니다.
이렇게 해서 구체적인 인스턴스가 만들어집니다. 예제로 확인해 봅시다.

```javascript
// 예제 3-13 | 생성자 함수
var Cat = function(name, age){
    this.bark = '야옹';
    this.name = name;
    this.age = age;
};

var choco = new Cat('초코',7);
var nabi = new Cat('나비',5);
console.log(choco, nabi);

/* 결과
* Cat { bark : '야옹' , name : '초코', age : 7 }
* Cat { bark : '야옹' , name : '나비', age : 9 }
* */
```

Cat이란 변수에 익명 함수를 할당했습니다. 이 함수 내부에서는 this에 접근해서 bark, name, age 프로퍼티에 각각 값을 대입합니다. 6번째주로가 7번째 줄에서는 new 명령어와 함께 Cat 함수를 호출해서 변수 choco, nabi에 각각 할당했습니다.
8번째 줄에서 choco와 nabi를 출력해보니 각각 Cat 클래스의 인스턴스 객체가 출력됩니다. 즉 6번째 줄에서 실행한 생성자 함수 내부에서의 this는 choco 인스턴스를 7번째 줄에서 실행한 생성자 함수 내부에서의 this는 nabi 인스턴스를 가리킴을 알 수 있습니다.



